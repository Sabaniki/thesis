\chapter{序論}
\label{chap:introduction}
\section{Service Function Chaining}

SFC とは，エンドツーエンド通信を提供するために必要なさまざまなサービスファンクション (SF) を決定及び順序付けし，それらを介するようにトラフィックを操作することを指す．
SF には，ファイアウォールや IP ネットワークアドレストランスレータ (NAT) などのネットワークサービスファンクションや，アプリケーション固有の機能が含まれる．
SFC アーキテクチャは，基礎となるネットワークトポロジから独立したトポロジを前提としている．
この基礎となるネットワークトポロジをアンダーレイネットワークといい，独立した SFC のためのネットワークトポロジをオーバレイネットワークという．
SFC アーキテクチャでは，パケットは通信の入口となるノードで分類され，そのノードで SFC 対応ドメイン内で適用する SF のセットを決める．
その後，任意の順番で各ファンクションで処理されるように転送される．

SFC アーキテクチャは，ネットワークの用途や拡張計画などのコンテキストに依存しない，汎用的な場面で利用可能な技術である．
つまり，SFC アーキテクチャは固定ネットワークやモバイルネットワーク，多くのデータセンターアプリケーションに適用できる．
SFC の構築においては，すべてのサービス機能 (SF) に適用できる標準の定義や特性は存在せず，各 SF は不透明な処理要素として扱われる．
また，特定の管理ドメインで有効な SF のグローバルリストや標準リストは存在せず，SF のセットは現在アクティブなサービスの機能であり，時間やネットワーク環境によって異なる場合がある．
SF のチェインとそれらを呼び出す基準は，SF 対応ドメインを運用する各管理エンティティに固有である．

SFC におけるサービス機能 (SF) は，受信したパケットの特定の処理を担当する機能である．
SF はプロトコルスタックのさまざまなレイヤで動作し，論理コンポーネントとして仮想要素として実現されるか，物理ネットワーク要素に組み込まれることがあ

\section{ソースルーティング}
\textbf{[Service Function Chaining に必要な技術であるソースルーティングについて， ソースルーティングを実現できる技術ついて説明するのだ]}

\section{SRv6}
\label{section:srv6}

SRv6は，IPv6 を使用するソースルーティングアーキテクチャの1つである．
SRv6 では，SRv6ヘッダ (SRH) と呼ばれる IPv6 拡張ヘッダに一連の識別子を埋め込むことで，ネットワークオペレータやアプリケーションはパケットが通過する中間地点を指定できる．
識別子はセグメント識別子 (SID) と呼ばれ，各 SID はネットワーク内の特定の場所で実行される，特定の機能を表す．
リスト状になっている SID の中で，どれが現在有効な SID であるかを指定するために，SRH にはセグメントレフト (segleft) と呼ばれるフィールドがある．
segleft は SID リストのインデックスで， $(SID の合計)-1$ から始まり，$0$ で終わる．
SID は，ネットワーク内の特定のセグメントに関連付けられた IPv6 アドレスである．
SID は \texttt{LOC:FUNCT:ARG} という構造になっており，IPv6 アドレスであるため，その長さの合計は 128bit である．
% TODO:
\textbf{ここから先の文章は前提知識がないと分かりにくいので本綴じまでに修正[}
\texttt{LOC} はロケータを表し，\texttt{FUNCT} は SID に関連付けられた転送動作の識別であり，\texttt{ARG} は転送動作に必要な追加情報をエンコードする領域である．
また，ロケータは \texttt{B:N} と表すこともできる．
ここで，\texttt{B} は SRv6 SID ブロック (SRv6 SID のために割り当てられた IPv6 プレフィックス) であり，\texttt{N} はSIDをインスタンス化するノードの識別子である．
\textbf{]}
% SIDはLOC:FUNCT:ARGという構造であり，LOCはロケータを表し，FUNCTはSIDに関連付けられたローカル動作を識別し，ARGはアクションに必要な追加情報をエンコードする可能性がある．
% ロケーターは，B:Nとしても表され，ここでBはSRv6 SIDブロック（SRv6 SIDsに割り当てられたIPv6プレフィックス）で，NはSIDを実装するノードの識別子である．

SRv6 ノードは，宛先 IPv6 アドレスがノードに設定されたローカル SID であるパケットを受信すると，SID に関連付けて事前定義された動作を実行する．
SRv6 のコンテキストにおいて，SRv6 ノードが実行する振る舞いは End ビヘイビアと称される．
現行の RFC8986~\cite{rfc8986} では，15 種類の End ビヘイビアが定義されており，その中で最も基本的なものは End である．
End ビヘイビアは，受信したパケットの SRH の segleft をデクリメントし，宛先 IPv6 アドレスを次の SID に置換する．
続いて，SRv6 ノードは更新された宛先 IPv6 アドレスに基づき，パケットを次のホップに転送する．
また，RFC8986 では，SID リストを含む SRH でパケットをカプセル化する動作も定義されており，これは Headend ビヘイビアと呼ばれる．

SRv6 の SID は IPv6 アドレスであるため，既存のルーティングプロトコルを用いて SID を経路情報として広告することにより，SRv6 ベースのネットワーク構築が可能である．
例えば，H.Encaps と End.DT4 はそれぞれヘッドエンドビヘイビア及びエンドビヘイビアに該当し，これら2つのビヘイビアを組み合わせることで layer-3 VPN を構成できる~\cite{rfc9252}．
H.Encaps は IPv4 または IPv6 パケットを SRH を含んだ IPv6 ヘッダで包み，一方 End.DT4 は SRH でカプセル化されたパケットの外部ヘッダを外す．
このようにパケットを新たな外部ヘッダで包むことをカプセル化と称し，包まれた外部ヘッダを取り外して内部のパケットを取り出すことをデカプセル化と称す．
入口となる SRv6 ノードでは， H.Encaps が出口側 SRv6ノードの End.DT4 SID に対応する IPv6 アドレスを宛先として持つ IPv6 ヘッダで，送信するパケットをカプセル化する．
該当パケットは SRv6 ルーティングインフラを通じて，End.DT4 SID の \texttt{LOC} に沿って出口 SRv6 ノードへと転送される．
SID は IPv6 アドレスであるため，通信の途中の経路ではカプセル化された外側の IPv6 ヘッダの宛先アドレスに基づいてルーティングされる．
出口 SRv6 ノードがパケットを受信すると，そのノードは End.DT4 を実行する．
End.DT4 を実行するとパケットはデカプセル化され，内部パケットは SID の \texttt{ARG} に関連付けられた VRF (Virtual Routing and Forwarding) テーブルに基づいてルーティングされる．
\section{導入}
\label{section:background}
Service Function Chaining (SFC) は，Software Defined Network (SDN) 及び Network Function Virtualization (NFV) の文脈で研究されているトピックである~\cite{nfv,sfc-on-sdn-nfv-servey,sfc-on-sdn-scenario,imple-sfc-with-openflow}．
SFC では，ネットワーク機能 (NF) を通過する順序や NF のタイプに関する情報を事前に定義し，それらのルールをネットワーク機器に配布する必要がある．
SFC ネットワークを構築するネットワーク機器は，事前に決定されたルールに従って受信したパケットを NF に導く．
パケットを NF へ導くためのルールは，SDN コントローラやルーティングプロトコルによってネットワーク機器に配布される．
ネットワーク機器は IP ルーティング上の最短経路に関係なく，配布された SFC ルールに従ってパケットを転送する次のホップを選択する必要がある．
また，パケットのヘッダにこれらのルールに合致させるための特別な情報を埋め込む手法が取られることもある．
SFC は，クラウドサービスプロバイダ (CSP)，アプリケーションサービスプロバイダ (ASP) 及びインターネットサービスプロバイダ (ISP) にとって，現在の静的な環境に代わる柔軟かつ経済的な選択肢を提供する~\cite{survey-on-sfc}．

SFC を実現可能な技術には，いくつかの候補が存在する．
例えば OpenFlow~\cite{openflow}，Network Service Header (NSH)~\cite{rfc8300}，\fussy MPLS~\cite{rfc8595}などである．
これらの技術はどれも，最短経路に関係なく，ルールに基づいて受信したパケットを意図した NF に導く，という要件を満たすことができる．
OpenFlow では，経路情報を管理する中央のコントローラが，実際にパケットを転送する OpenFlow スイッチに対して明示的にパケット転送ルールを設定する．
OpenFlow スイッチは，コントローラによって適切に管理されたルールに従い，パケットを意図した NF に転送する．
OpenFlow のもつこのアーキテクチャは，従来のルーティングプロトコルに基づかない柔軟な経路制御を可能にする．
NSH は Service Path Identifier (SPI) とService Index (SI) によって NF を識別する．
NSH ノードは，パケットに付与された NSH 内の SPI，SI に基づいてパケットを転送する．
NSH は，サービスプレーンと呼ばれる専用のオーバーレイネットワークを作成し，そのオーバレイネットワーク内でサービスを転送する．
このオーバレイネットワークを構築する，というアーキテクチャにより，NSH では基礎となるネットワークトポロジを変更することなくサービス転送を可能にする．
一方，MPLS では，直接 NSH を使用する代わりに，MPLS ラベルスタックを利用する．
このラベルスタックには，パケットが通過すべきノードの順序がホップバイホップで含まれている．
ラベルスタック内で表現されるノードはルータだけでなく，NF も含まれるため，そのラベルスタックに基づいてパケットを転送する事で SFC を実現できる．
このアプローチもまた，基礎となるネットワークトポロジを変更せずに SFC を実現するために必要な，最短経路によらないパケット転送を達成する．

Segment Routing (SR)，特に Segment Routing over IPv6 (SRv6) もまた，SFCを実装するために使用される技術の1つである．
SR では，リンク，ノード，サービスといったネットワーク内の各エンティティを\textbf{セグメント}として表現する．
SRv6 パケットのヘッダ (SRH) には，セグメントリストと呼ばれる，そのパケットが通過すべきセグメントの順序を示したリストが含まれている．
SRv6 では，セグメントを識別するための ID (SID) として，IPv6 アドレスを使用する．
言い換えれば，SRv6 は IPv6 ルーティングインフラをその基盤として利用し，SRH 内で定義された順序に従って，任意のセグメントを経由してパケットを転送する．
SRv6 は，NF が実行されるノードをセグメントとして表現し，SID を割り当て，任意の順序で NF を通過するようにパケットを転送することで SFC を実現する．

SRv6 では，NF を SID で表し，セグメントリストに基づいて適切にパケットを転送をすることで，SRv6 を基盤とした SFC ネットワークを実現できる．
しかし，SRv6 レイヤよりも上位にある NF の振る舞いと，基盤となる IPv6 ルーティングインフラをどのように統合するかは明確でない．
例えば，IPv4パケットの Network Address Translation (NAT) を SRv6 ネットワーク内の NF として考慮する場合を考える．
SRv6 ネットワーク内において，IPv4パケットは，SR Header (SRH) を含む外部 IPv6 ヘッダでカプセル化される．
NF で動作する NAT の実装が SRv6 に対応していない場合，SR プロキシ~\cite{ietf-spring-sr-service-programming-08}が必要となり，ネットワーク構成や運用における複雑さが増加してしまう~\cite{draft-scexp}．
実装が内部パケットへの NAT と SRv6 に則した転送動作を同時に実行できる場合，それはレイヤバイオレーションとなる． 
Linux には，SERA~\cite{sera} という iptables を拡張したファイアウォールアプリケーションが存在する．
SERA は SRH でカプセル化されたパケットについて，カプセル化された内部パケットのヘッダ情報にマッチする iptables のフィルタールールを適用できる．
SRv6 での基本的な転送動作として，End と呼ばれる動作がある．
SERA は iptables を拡張することで，この End 動作を処理する機能も実装されている．
ただし，既にLinux カーネルには IPv6 ルーティング，及び SRv6 End 動作に関する処理が実装されている．
SERA は，Linux kernel に実装されている SRv6 機能を使わずに，独自に改良した iptables アクションによって End 動作を処理する．
つまり，SERA は Linux kernel 内で統合されている IPv6 ルーティングインフラと SRv6 処理機能を使わずに，独自に拡張した iptables によって SRv6 とフィルタリングサービスとしての NF を統合している．

本論文では，既存の netfilter ベースアプリケーションの実装を変更することなく SRv6 対応 NF として扱えるようにする，End.AN.NF 提案する．
End.AN.NF は Linux netfilter を NF として扱えるようにしつつ，Linux に実装されている IPv6 ルーティングインフラを活用する．
End.AN.NF は受信した SRv6 内部パケットに対して，netfilter のフックポイントを透過的するように設計されている．
本論文では End.AN.NF を Linux カーネル上で実装し，スループットとレイテンシを評価した．
評価の結果，End.AN.NF は End.DT 4と H.Encaps の組み合わせによる SRv6 内部パケットへの netfilter 適用と比較し て27\% 高いスループットと 3.0 マイクロ秒低いレイテンシを実現した．
さらに，End.AN.NFのレイテンシは，End.DT4とH.Encapsの組み合わせよりも3.0マイクロ秒低い．
また，End.AN.NFのレイテンシはマイクロ秒解像度でEnd動作と同じである．

\section{本論文の目的と構成}
本論文における以降の構成は次の通りである．
\ref*{chap:introduction}章では，本論文の構成，及び本論文の概要を述べる．
\ref*{chap:related_works}章では，サービスファンクションチェイニングに関する前提知識，及びそれを実現する技術について解説し，本論文の概要について述べる．
\ref*{chap:design_and_impl}章では，本論文の提案する新たな SRv6 End behavior である End.AN.NF についての詳細な動作，及び実装について述べる．
\ref*{chap:evaluation}章では，実装した End.AN.NF について，レイテンシ及びスループットの性能を特定のを変化させながら性能の計測する．
\ref*{chap:conclusion}章では，本研究における結論と今後の展望について述べ，End.AN.NF に必要なネットワーク制御プレーンについて検討する．